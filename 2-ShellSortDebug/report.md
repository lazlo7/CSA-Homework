# Отчет

## 1. Оценить работоспособность программы shell-sort
- Программа корректно работает на наборе неположительных чисел.
- На некоторых тест-кейсах встречается не вводившийся 0.
- Программа иногда корректно работает на наборе, где есть положительные числа.  

## 2. Test-case
in:  2 1 5 -12 3 -9  
out: -12 -9 1 2 3 5  
Массив отсортирован корректно.

## 3. Other test-cases
Тест-кейсы:
1.  in:  
    out:  
2.  in: 1  
    out: 0  
3.  in: 1 2  
    out: 0 1   
4.  in: 1 2 3  
    out 0 1 2   
5.  in: 1 2 3 4  
    out: 0 1 2 3   
6.  in: 1 2 3 4 5  
    out: 0 1 2 3 4   
7.  in: 1 2 3 4 5 6  
    out: 1 2 3 4 5 6   
8.  in: 1 2 3 4 5 6 7  
    out: 0 1 2 3 4 5 6   
9.  in: 1 2 3 4 -5 -6 -7 8 9 10   
    out: -7 -6 -5 1 2 3 4 8 9 10 N  
10. in: 1 2 3 4 -5 -6 -7 8 9 10 11 14 13 12 
    out: 7 -6 -5 1 2 3 4 8 9 10 11 12 13 14 N  

Наблюдение:  
При вводе n != 6 + 4*k чисел максимальное положительное число, если такое есть, заменяется на 0, соответственно меняя свое место в отсортированном массиве.  

## 4. и 5.
Создадим копию программы - shell-sort-fixed.c  
Все дальнейшие действия будем проводить с ней.  

Скомпилируем shell-sort-fixed.c с флагом для загрузки символов отладки.  
`gcc -g shell-sort-fixed.c -o shell-sort-fixed`  

Запускаем gdb.  
`gdb ./shell-sort-fixed`  

Ставим breakpoint на main  
`(gdb) break main`

Запускаем программу и передаем аргументы, на которых программа выдает некорректный ответ.  
`(gdb) run 1 2 3 4 5`  

Ставим на дисплей массив введенных чисел a[] (по умолчанию там мусор).  

    (gdb) display *a@(argc - 1)
    1: *a@(argc - 1) = {-98693133, -284203435, -443987776, 1447122753, -1924377279}

Через next доходим до вызова функции shell_sort. Видим, что массив заполняется корректно.

    (gdb) next
    33        for (i = 0; i < argc - 1; i++) {
    1: *a@(argc - 1) = {0, 0, 0, 0, 0}
    (gdb) next
    34          a[i] = atoi(argv[i + 1]);
    1: *a@(argc - 1) = {0, 0, 0, 0, 0}
    (gdb) next
    33        for (i = 0; i < argc - 1; i++) {
    1: *a@(argc - 1) = {1, 0, 0, 0, 0}
    (gdb) next
    34          a[i] = atoi(argv[i + 1]);
    1: *a@(argc - 1) = {1, 0, 0, 0, 0}
    (gdb) next1 2 3 4 -5 -6 -7 8 9 10 11 14 13 12
    1: *a@(argc - 1) = {1, 2, 3, 0, 0}
    (gdb) next
    33        for (i = 0; i < argc - 1; i++) {
    1: *a@(argc - 1) = {1, 2, 3, 4, 0}
    (gdb) next
    34          a[i] = atoi(argv[i + 1]);
    1: *a@(argc - 1) = {1, 2, 3, 4, 0}
    (gdb) next
    33        for (i = 0; i < argc - 1; i++) {
    1: *a@(argc - 1) = {1, 2, 3, 4, 5}
    (gdb) next
    36        shell_sort(a, argc);
    1: *a@(argc - 1) = {1, 2, 3, 4, 5}

Переходим в shell_sort через step.

    (gdb) step
    shell_sort (a=0x5555555592a0, size=6) at shell-sort-fixed.c:8
    8         int h = 1;

Передан массив a[] и его размер size.

    (gdb) list
    3       #include <stdio.h>
    4       #include <stdlib.h>
    5
    6       static void shell_sort(int a[], int size) {
    7         int i, j;
    8         int h = 1;
    9
    10        do {
    11          h = h * 3 + 1;
    12        } while (h <= size);

Ставим на display массив a[].

    (gdb) display *a@(size)
    2: *a@(size) = {1, 2, 3, 4, 5, 0}

Вывод display для этого массива отличается от display массива в функции main, хотя был передан один и тот же массив.  
Массив в shell_sort имеет на размер на 1 больше, чем в main.  
Значит, переданное значение size неверно.  
Возвращаемся в shell-sort-fixed.c и меняем соответствующую строку.  
`shell_sort(a, argc - 1);`

После компиляции и прогона тест-кейсов, ошибка пропадает.